


1. Core is rejecting messages based on the current validator set, which is the
validators defined by the current height. If we assume that in an epoch all
validators rotate and none of them do so simultaneously, but instead that first
one validator changes receives the new block and realises they have been
elected and then a second and so on. The first validator will send its
consensus messages to all the validators that it sees, but none of those nodes
will know that they are validators yet and will discard the messages. The next
validator's message will only reach the first validators message and so on.
Averaging out over the whole set of validators we see that each validator will
receive messages from 1/2 of the other validators. This is not enogh to commit
to a value and so there will be a round change. This is an extreme case but it
highlights problems with this approach.

2. The check of

	// We will never do consensus on any round less than desiredRound.
	if c.current.Round().Cmp(c.current.DesiredRound()) > 0 {
		panic(fmt.Errorf("Current and desired round mismatch! cur=%v des=%v", c.current.Round(), c.current.DesiredRound()))
	}

Seems redundant becasue that should never be able to happen, if its a sanity
check then this seems to be the wrong place for it. It should instead be
executed after changing the current or desiered round. Checking it for each
message is a waste.

3. There is significant processing dedicated to outputting a warning that I do not understand.

	preprepare := msg.Preprepare()
	// Git validator set for the given proposal
	valSet := c.backend.ParentBlockValidators(preprepare.Proposal)
	prevBlockAuthor := c.backend.AuthorForBlock(preprepare.Proposal.Number().Uint64() - 1)
	proposer := c.selectProposer(valSet, prevBlockAuthor, preprepare.View.Round.Uint64())

	// We no longer broadcast a COMMIT if this is a PREPREPARE from the correct proposer for an existing block.
	// However, we log a WARN for potential future debugging value.
	if proposer.Address() == msg.Address && c.backend.HasBlock(preprepare.Proposal.Hash(), preprepare.Proposal.Number()) {
		logger.Warn("Would have sent a commit message for an old block")
		return nil
	}

The message says would have send a commit for an old block, its not clear what
that means because we don't send commits for old blocks.

4. We perform the following check when adding a future message to the backlog.

	// Store in backlog (if it's not from self)
	if msg.Address != c.address {
		c.backlog.store(msg)
	}

It seems like an impossible situation to be in. I don't think we ever decrement
round or sequence, so this shouldn't be needed.

5. Backend.Validators and Backend.ParentBlockValidators are being used in
several places where the randomness added to the set is not required, thus
resulting in many unnecessary contract calls to get the randomness. This
happens when handling commit messages and preprepare messages. So potentially
hundreds of times per block.

6. Multiple proposals, how is that handled? I think first one wins.

7. Rather than having createRoundState and newRoundState which both return
RoundState objects it might be nicer to just load state directly in core.Start
and use that to create a new round state.

8. istanbul.StartValidating returns an error that is not checked.

miner/worker.go:206
			istanbul.StartValidating()
